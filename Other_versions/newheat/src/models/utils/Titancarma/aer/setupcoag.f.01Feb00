       subroutine setupcoag
c
c
c  @(#) setupcoag.f  Jensen  Oct-1995
c  This routine sets up mapping arrays and precomputed
c  factors for coagulation.
c
c  This routine requires that <ckernel> has been defined.
c  (setupckern.f must be called before this)
c
c
c  Argument list input:
c    None.
c
c  Argument list output:
c    None.
c
c
c  Include global constants and variables
c
      include 'globaer.h'
c
c
      dimension kbin(NGROUP,NGROUP,NGROUP,NBIN,NBIN)
c
c
c  Announce entry to this routine
c
      if( DEBUG ) write(LUNOPRT,'(/,a)') 'Enter setupcoag'
c
c-----------------------------------------------------------------
c
c  Fill <icoag>, maintaining diagonal symmetry
c
      do jg = 2, NGROUP
        do ig = 1, jg-1
          icoag(ig,jg) = icoag(jg,ig)
        enddo
      enddo
c
c
c  For each element <ielem> and each group <ig>, determine which element in <ig>
c  contributes to production  in <ielem>: <icoagelem(ielem,ig)>.
c  If no elements in <ig> are transfered into element <ielem> during coagulation,
c  then set <icoagelem(ielem,ig)> to 0.
c
      do ielem = 1,NELEM

        isolto = isolelem(ielem)           ! target solute type
        igto = igelem(ielem)               ! target group

        do ig = 1, NGROUP                 ! source group
c
c  If <ielem> is particle number concentration type or <ig> is pure group, then
c  the source element is the particle number concentration element of group <ig>.
c
          if( ( itype(ielem) .eq. I_INVOLATILE .or. 
     $          itype(ielem) .eq. I_VOLATILE ) .or.
     $          ncore(ig) .eq. 0 ) then
            icoagelem(ielem,ig) = ienconc(ig)
c
c  Otherwise, use solute types to determine which source element matches
c  target core mass element.
c
          else
            isolfrom = isolelem(ienconc(ig))   ! source solute type
            if( isolfrom .eq. isolto ) then
              icoagelem(ielem,ig) = ienconc(ig)
            else
              do ic = 1,ncore(ig)
                iecore = icorelem(ic,ig)       ! absolute element number of core
                isolfrom = isolelem(iecore)    ! source solute type
                if( isolfrom .eq. isolto )
     $            icoagelem(ielem,ig) = iecore
              enddo
            endif
          endif
c
c  If <ielem> is a core mass type and <ig> is a pure CN group and the
c  solutes don't match, then set <icoagelem> to zero to make sure no
c  coag production occurs.
c
          if( itype(ielem) .eq. I_COREMASS .and.
     $        itype(ienconc(ig)).eq. I_INVOLATILE
     $        .and. ncore(ig) .eq. 0 ) then
            isolfrom = isolelem(ienconc(ig))
            if( isolfrom .ne. isolto ) then
              icoagelem(ielem,ig) = 0
            endif
          endif

        enddo          ! end of (ig = 1, NGROUP)

      enddo            ! end of (ielem = 1,NELEM)
c
c
c  Calculate lower bin <kbin> which coagulated particle goes into
c  and make sure it is less than <NBIN>+1
c
c  Colliding particles come from group <ig>, bin <i> and group <jg>, bin <j>
c  Resulting particle lands in group <igrp>, between <ibin> and <ibin> + 1
c

      do igrp = 1, NGROUP
        do ig = 1, NGROUP
          do jg = 1, NGROUP
            do i = 1, NBIN
              do j = 1, NBIN

                rmsum = rmass(i,ig) + rmass(j,jg)

                do ibin = 1, NBIN-1
                  if( rmsum .ge. rmass(ibin,igrp) .and.
     $                rmsum .lt. rmass(ibin+1,igrp) ) then
                    kbin(igrp,ig,jg,i,j) = ibin
                  endif
                enddo

                if( rmsum .ge. rmass(NBIN,igrp) )
     $                   kbin(igrp,ig,jg,i,j) = NBIN

              enddo
            enddo
          enddo
        enddo
      enddo
c
c
c  Calculate partial loss fraction
c
c  This fraction is needed because when a particle in bin <i> collides
c  with a particle in bin <j> resulting in a particle whose mass falls
c  between <i> and <i>+1, only partial loss occurs from bin <i>.
c
c  Since different particle groups have different radius grids, this
c  fraction is a function of the colliding groups and the resulting group.
c
      do igrp = 1, NGROUP
        do ig = 1, NGROUP
          do jg = 1, NGROUP

            if( igrp .eq. icoag(ig,jg) ) then

              do i = 1, NBIN
                do j = 1,NBIN

                  volx(igrp,ig,jg,i,j) = 1.
 
                  if(kbin(igrp,ig,jg,i,j).eq.i) then
 
                    rmkbin = rmass(kbin(igrp,ig,jg,i,j),igrp)
                    volx(igrp,ig,jg,i,j) = 1. -
     $                  (rmrat(igrp)*rmkbin-rmass(i,ig)-rmass(j,jg))
     $                  /(rmrat(igrp)*rmkbin-rmkbin)*
     $                  rmass(i,ig)/(rmass(i,ig) + rmass(j,jg))

                  endif

                enddo
              enddo
            endif
          enddo
        enddo
      enddo
c
c
c  Calculate mapping functions that specify sets of quadruples
c  (group pairs and bin pairs) that contribute to production
c  in each bin. Mass transfer from <ig,i> to <igrp,ibin> occurs due to
c  collisions between particles in <ig,i> and particles in <jg,j>.
c  2 sets of quadruples must be generated:
c     low: k = ibin and (k != i or ig != igrp)  and  icoag(ig,jg) = igrp
c      up: k+1 = ibin        and  icoag(ig,jg) = igrp
c
c  npair#(igrp,ibin) is the number of pairs in each set (# = l,u)
c  i#, j#, ig#, and jg# are the bin pairs and group pairs in each
c  set (# = low, up)
c
      do igrp = 1, NGROUP
        do ibin = 1, NBIN

          npairl(igrp,ibin) = 0
          npairu(igrp,ibin) = 0

          do ig = 1, NGROUP
          do jg = 1, NGROUP
            do i = 1, NBIN
            do j = 1, NBIN

              kb = kbin(igrp,ig,jg,i,j)
              ncg = icoag(ig,jg)

              if( kb+1.eq.ibin .and. ncg.eq.igrp ) then
                npairu(igrp,ibin) = npairu(igrp,ibin) + 1
                iup(igrp,ibin,npairu(igrp,ibin)) = i
                jup(igrp,ibin,npairu(igrp,ibin)) = j
                igup(igrp,ibin,npairu(igrp,ibin)) = ig
                jgup(igrp,ibin,npairu(igrp,ibin)) = jg
              endif

              if( kb.eq.ibin .and. ncg.eq.igrp .and.
     $          (i.ne.ibin .or. ig.ne.igrp) ) then
                npairl(igrp,ibin) = npairl(igrp,ibin) + 1
                ilow(igrp,ibin,npairl(igrp,ibin)) = i
                jlow(igrp,ibin,npairl(igrp,ibin)) = j
                iglow(igrp,ibin,npairl(igrp,ibin)) = ig
                jglow(igrp,ibin,npairl(igrp,ibin)) = jg
              endif

            enddo
            enddo
          enddo
          enddo
        enddo
      enddo
c
c
c  Do some extra debugging reports  (normally commented)
c
      write(LUNOPRT,*) ' '
      write(LUNOPRT,*) 'Coagulation bin mapping arrays'
      do igrp = 1, NGROUP
        do ibin = 1,3
          write(LUNOPRT,*) 'igrp, ibin = ',igrp, ibin
          do ipair = 1,npairl(igrp,ibin)
            write(LUNOPRT,*) 'low:np,ig,jg,i,j ',
     $          ipair,iglow(igrp,ibin,ipair),
     $      jglow(igrp,ibin,ipair), ilow(igrp,ibin,ipair),
     $            jlow(igrp,ibin,ipair)
          enddo
          do ipair = 1,npairu(igrp,ibin)
            write(LUNOPRT,*) 'up:np,ig,jg,i,j ',
     $          ipair,igup(igrp,ibin,ipair),
     $      jgup(igrp,ibin,ipair), iup(igrp,ibin,ipair),
     $           jup(igrp,ibin,ipair)
          enddo
        enddo
      enddo
c
c
c  Calculate variables needed in routine coagp.f
c
      do igrp = 1, NGROUP
        do ig = 1, NGROUP
        do jg = 1, NGROUP

          if( igrp .eq. icoag(ig,jg) ) then

            do i = 1, NBIN
            do j = 1, NBIN

              rmk = rmass(kbin(igrp,ig,jg,i,j),igrp)
              rmsum = rmass(i,ig) + rmass(j,jg)

              do k = 1, NZ

                pkernl = ckernel(k,i,j,ig,jg)*
     $                   (rmrat(igrp)*rmk - rmsum) /
     $                   (rmrat(igrp)*rmk - rmk)

                pkernu = ckernel(k,i,j,ig,jg)*
     $                   (rmsum - rmk) /
     $                   (rmrat(igrp)*rmk - rmk)

                if( kbin(igrp,ig,jg,i,j) .eq. NBIN )then
                  pkernl = ckernel(k,i,j,ig,jg)*
     $                     rmsum / rmass(NBIN,igrp)
                  pkernu = 0.
                endif
  
                pkernel(k,i,j,ig,jg,igrp,1) = pkernu *
     $                                        rmass(i,ig)/rmsum
                pkernel(k,i,j,ig,jg,igrp,2) = pkernl *
     $                                        rmass(i,ig)/rmsum
                pkernel(k,i,j,ig,jg,igrp,3) = pkernu *
     $                                        rmk*rmrat(igrp)/rmsum
                pkernel(k,i,j,ig,jg,igrp,4) = pkernl *
     $                                        rmk/rmsum
                pkernel(k,i,j,ig,jg,igrp,5) = pkernu *
     $                                 ( rmk*rmrat(igrp)/rmsum )**2
                pkernel(k,i,j,ig,jg,igrp,6) = pkernl *
     $                                        ( rmk/rmsum )**2

              enddo

            enddo
            enddo

          endif

        enddo
        enddo
      enddo
c
c
c  Return to caller with coagulation mapping arrays defined
c
      return
      end
