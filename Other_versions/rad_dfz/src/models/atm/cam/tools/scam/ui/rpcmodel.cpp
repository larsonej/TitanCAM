#if (defined SUN) || (defined Linux)
//  RPC code only compiles correctly on Sun and Linux platforms

//
// File: rcpmodel.cpp
// implementation of RPCModel
//


#ifndef lint
static char rcsid[]="$Header: /Users/fabiano/tmp/cam_titan_repository/src/models/atm/cam/tools/scam/ui/rpcmodel.cpp,v 1.1 2006/02/15 05:55:51 fabiano Exp $";
#endif

#include <errno.h>
#include <signal.h>             // for signals
#include <cstdlib>             // for exit
#include <cstring>             // for strncpy
#include <rpc/rpc.h>            // for clnt_create, clnt_perror, et al.

#include "dataset.h"
#include "max.h"                // definition of NUM_SWITCHES
#include "field.h"              // declaration of Field class
#include "manager.h"
#include "rpcmodel.h"           // declaration of RPCModel class
#include "scam_rpc.h"           // header file generated by rpcgen
                                //  containing rpc function protos
//
//  globals
//
static CLIENT* client = NULL;   /* RPC  client handle */


//------------------------------------------------------------------
// cleanup: destroys the client connection
//------------------------------------------------------------------
static void
cleanup()
{
    if ( client != NULL )
        clnt_destroy( client );
}

//--------------------------------------------------------
// handle_interrupt: handles interrupts to exit gracefully
//                   closes active connections and exits
//               input: number of the signal caught - unused
//--------------------------------------------------------
static void
handle_interrupt( int sig )
{
    //
    // to do:
    // add code here to shut down the server on the remote machine
    //
    
    cleanup();
    exit( 0 );
}

//------------------------------------------------------
//  RPCModel: constructor, creates the client connection
//------------------------------------------------------

RPCModel::RPCModel()
:Model()
{
    struct    sigaction in;     // signal for interrupt 

    //
    // Set up a handler for catching interrupts
    //
#ifdef SGI
    in.sa_handler = (void (*)())handle_interrupt;
#else
    in.sa_handler = handle_interrupt;
#endif
    in.sa_flags = 0;
    if ( sigemptyset( &in.sa_mask ) == -1 ) {
        cerr << "WARNING "__FILE__":" << __LINE__ 
             << " : cannot clear interrupt handler: " << strerror( errno );
    }
    if ( sigaction( SIGINT, &in, NULL ) == -1 ) {
        cerr << "WARNING"__FILE__":" << __LINE__ 
             << " : cannot install interrupt handler: " << strerror( errno );
    }

}


//-----------------------------------------------------
//  ~RPCModel: destructor, cleans up client connection
//-----------------------------------------------------

RPCModel::~RPCModel()
{
    cleanup();
}

bool
RPCModel::Connect()
{
    char errormsg[256];
#ifdef DBG
    struct timeval timeout = { 600, 0 }; // 10 minute timeout 
#else
    struct timeval timeout = { 30, 0 }; // 30 second timeout 
#endif
      //
      // create the client
      //
    if ( client == NULL ) {
        if (( client = clnt_create( _host.c_str(), SCAM_PROG, SCAM_VERS, "tcp" ))
            == NULL ) {
            sprintf( errormsg, "ERROR: "__FILE__" "": Connection to %s failed\n ", _host.c_str() );
            clnt_pcreateerror( errormsg );
            return false;
        }
          //
          // set the timeout
          //
        if ( !clnt_control( client, CLSET_TIMEOUT, (char*)&timeout )) {
            cerr << "ERROR :RPCModel::Connect() Unable to set timeout." << endl;
            return false;
        }
    }
    return true;
}

//-----------------------------------------------------
//  Init: calls the model initialization function
//         inputs: model initialization pararameters
//-----------------------------------------------------
int
RPCModel::Init(bool isRestart)
{

    static struct init_data rid;  // init data struct
    int*   init_status;               // status returned from init function
    //
    // Fill in the rpc data structure with the data used for initialization
    //
    for ( int i=0; i<NUM_SWITCHES; i++ )
        rid.sw[i] = switches[i];
    rid.lat =  latitude;
    rid.lon =  longitude;
    rid.bd = baseDate;
    rid.bs = baseSecs;
    rid.rt = runType;
    rid.sl = stepLen;
    rid.rst = isRestart;
    rid.ie = MANAGER.SeedVal();
    strcpy( rid.ana, dataset[ANAL]->name().c_str() );
    strcpy( rid.ini, dataset[MODEL]->name().c_str() );
    strcpy( rid.iop, dataset[IOP]->name().c_str() );
    strcpy( rid.lsmini, dataset[LSMINI]->name().c_str() );
    strcpy( rid.ozo, dataset[OZON]->name().c_str() );
    strcpy( rid.prs, dataset[PRES]->name().c_str() );
    strcpy( rid.abs, dataset[ABSEMS]->name().c_str() );
    strcpy( rid.optics, dataset[AEROPTICS]->name().c_str() );
    strcpy( rid.mass, dataset[AERMASS]->name().c_str() );
    strcpy( rid.sst, dataset[SST]->name().c_str() );
    strcpy( rid.lsmpft, dataset[LSMPFT]->name().c_str() );
    strcpy( rid.lsmsurf, dataset[LSMSRF]->name().c_str() );
    if ( dataset[SIC] != 0 ) 
        strcpy( rid.sic, dataset[SIC]->name().c_str() );
    if ( dataset[USER] != 0 ) 
         strcpy( rid.usr, dataset[USER]->name().c_str() );
    
    //
    // Make the RPC call
    //
    if (( init_status = init_model_1( &rid, client )) == NULL ) {
        clnt_perror( client, " ERROR: "__FILE__": RPCModel::Init() - RPC call (init_model) failed " );
        cleanup();
        return false;
    }
    initStatus = *init_status;
    if( initStatus != 0 )  // error on initialization
        return initStatus;
    
    baseLevs = currLevs = GetLevels();
    baseILevs = currILevs = GetILevels();
    
    currentStep = 0;
    return 0;
}

void 
RPCModel::BuildFieldList()
{
    struct  field_info *fi; // field info returned from rpc call
    int fid = 0;                // current field id
    
    while ( 1 ) {
        fi = get_field_info_1( &fid , client );
        if ( fi == NULL ) {
            clnt_perror( client, "ERROR: "__FILE__" "": get_layer_field RPC call failed" );
            cleanup();
            exit( -1 );
        }
        if ( fi->size <= 0 )     // no more fields
            break;              
          // check for duplicates
        if ( fields.find( fi->name ) != fields.end() )
            break;
        Field* f = new Field( fi->name, fi->longname, fi->units,
                              fi->std_units, fi->mult, fi->min,
                              fi->max, (bool)fi->is_shown, (bool)fi->is_modifiable,
                              (bool)fi->is_averaged, fi->size, fid );
        fields.insert( fieldpair( f->Name(), f ) );
        fid++;                  // get next field
    }
}


//-----------------------------------------------------
//  ReadField: Retrieves a field's value from the model
//           input: Field object to get data for
//-----------------------------------------------------
void
RPCModel::ReadField( Field& f )
{
    struct  field_data   *fd;  // field data returned from rpc call

    int fieldID;

    fieldID = f.FieldID();
      //
      // make the rpc call
      //
    fd = get_field_1( &fieldID, client );
    if ( fd == NULL ) {
        clnt_perror( client, "error: get_layer_field RPC call failed" );
        cleanup();
        exit( -1 );
    }
    f.SetData( fd->data );

}

void
RPCModel::ReadDatasetVar( int type, string& varname, int size, int* data )
{
    struct dataset_req req;
    struct dataset_var_int* var;

    //
    // initialize the request struct
    strcpy( req.dataset, dataset[type]->name().c_str() );
    strcpy( req.varname, varname.c_str() );
    //
    // make the rpc call
    //
    var = get_dataset_var_int_1( &req, client);
    if ( var == NULL ) {
        clnt_perror( client, "error: ReadDatasetVar RPC call failed" );
        cleanup();
        exit( -1 );
    }
    memcpy( data, &var->data, size * sizeof( int ) );
}

void
RPCModel::ReadDatasetVar( int type, string& varname, int size, real_t* data ) 
{
    struct dataset_req req;
    struct dataset_var_real* var;

    //
    // initialize the request struct
    strcpy( req.dataset, dataset[type]->name().c_str() );
    strcpy( req.varname, varname.c_str() );
    //
    // make the rpc call
    //
    var = get_dataset_var_real_1( &req, client);
    if ( var == NULL ) {
        clnt_perror( client, "error:ReadDatasetVar RPC call failed" );
        cleanup();
        exit( -1 );
    }
    memcpy( data, &var->data, size * sizeof( real_t ) );
//    return var->found;
}

int 
RPCModel::DatasetDimSize( int type, string& dimname )
{
    struct dataset_req req;
    int * dimsize;

    //
    // initialize the request struct
    strcpy( req.dataset, dataset[type]->name().c_str() );
    strcpy( req.varname, dimname.c_str() );
    //
    // make the rpc call
    //
    dimsize = get_dataset_dimsize_1( &req, client);
    if ( dimsize == NULL ) {
        clnt_perror( client, "error:DatasetDimSize RPC call failed" );
        cleanup();
        exit( -1 );
    }
    return *dimsize;
}

//-----------------------------------------------------
//  Levels: Retrieves the models pressure levels data
//             input: array to hold level data
//             returns the number of levels
//-----------------------------------------------------
const vector<real_t>&
RPCModel::GetLevels()
{
    struct level_data* ld; // level data returned from rpc call
    
    //
    // make the rpc call
    //
    ld = get_levels_1( NULL, client );
    if ( ld == NULL ) {
        clnt_perror( client, "error:get_levels RPC call failed" );
        cleanup();
        exit( -1 );
    }
    numLevs = ld->nlev;
    currLevs.resize( numLevs );
    copy( ld->levels, ld->levels+numLevs, currLevs.begin() );
    return currLevs;
}
//-----------------------------------------------------
//  Levels: Retrieves the models interface pressure levels data
//             input: array to hold level data
//             returns the number of levels
//-----------------------------------------------------
const vector<real_t>&
RPCModel::GetILevels()
{
    struct level_data* ld; // level data returned from rpc call
    
    //
    // make the rpc call
    //
    ld = get_levels_1( NULL, client );
    if ( ld == NULL ) {
        clnt_perror( client, "error:get_levels RPC call failed" );
        cleanup();
        exit( -1 );
    }
    numILevs = ld->ilev;
    currILevs.resize( numLevs );
    copy( ld->ilevels, ld->ilevels+numILevs, currILevs.begin() );
    return currILevs;
}

bool
RPCModel::CheckDataset( const string& filename, int type )
{
    cerr << "Warning: RPCModel::CheckDataset(): dataset checking not implemented on remote files" << filename << endl;
    return TRUE;
}

void
RPCModel::SetDataset( int type, const string& filename ) throw ( NcErr )
{
    Dataset* data = new Dataset( filename, type );
    delete dataset[type];
    dataset[type] = data;
}

    
//---------------------------------------------------------------------------
// Resets an averaged field
//---------------------------------------------------------------------------
void
RPCModel::ResetField( const Field& f )
{

    int* status;                // RPC return status
    int fieldID;

    fieldID = f.FieldID();
    
    if ( !f.IsAveraged() )
        return;
    status = reset_field_1( &fieldID, client );
    if ( status == NULL ) {
        clnt_perror( client, "error:ResetField RPC call failed" );
        cleanup();
        exit( -1 );
    }
}





//---------------------------------------------------------------------------
// WriteField: Sets a field's value in the model
//          input: Field object containing data to be set in the model
//---------------------------------------------------------------------------
void
RPCModel::WriteField( const Field& f )
{
    int* status;                // RPC return status

    static struct field_data fd; // field data passed in rpc call

    fd.id = f.FieldID();
    copy( f.Data().begin(), f.Data().begin()+f.NumLevs(), fd.data );

      //
      // Make the RPC call
      //
    status = set_field_1( &fd, client );
    if ( status == NULL ) {
        clnt_perror( client, "error:WriteField RPC call failed" );
        cleanup();
        exit( -1 );
    }

}

void
RPCModel::SetRemoteHost( const string& host )
{
    _host = host;
}

//-----------------------------------------------------
//  Step: calls the model time stepping function
//-----------------------------------------------------
void
RPCModel::Step()
{
    int* rpc_status;                // RPC return status

    //
    // make the rpc call
    //
    if(( rpc_status = step_1( NULL, client )) == NULL ) {
        clnt_perror( client, "Step RPC call failed" );
        cleanup();
        exit( -1 );
    }
    currentStep++;   
}






#endif // defined sun or linux
